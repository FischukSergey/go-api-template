package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

func main() {
	if len(os.Args) != 4 {
		log.Fatalf("invalid args count: %d", len(os.Args)-1)
	}

	pkg, typesArg, out := os.Args[1], os.Args[2], os.Args[3]
	types := strings.Split(typesArg, ",")

	// Отладочная информация
	log.Printf("Types to generate: %v (count: %d)", types, len(types))
	for i, t := range types {
		log.Printf("Type %d: '%s'", i, t)
	}

	if err := run(pkg, types, out); err != nil {
		log.Fatal(err)
	}

	p, _ := os.Getwd()
	log.Printf("%v generated", filepath.Join(p, out))
}

func run(pkg string, types []string, outFile string) error {
	// Создаем файл для всех типов
	f, err := os.Create(outFile)
	if err != nil {
		return fmt.Errorf("create file: %w", err)
	}
	defer f.Close()

	// Записываем заголовок файла
	header := fmt.Sprintf(`// Code generated by cmd/gen-types; DO NOT EDIT.
package %s

import (
	"database/sql/driver"
	"errors"
	"github.com/google/uuid"
)

`, pkg)
	if _, err := f.WriteString(header); err != nil {
		return fmt.Errorf("write header: %w", err)
	}

	// Определение шаблона для каждого типа
	const typeTpl = `
type {{.Type}} uuid.UUID

func (c {{.Type}}) String() string {
	return uuid.UUID(c).String()
}

//TextMarshaler реализует интерфейс encoding.TextMarshaler
func (c {{.Type}}) MarshalText() ([]byte, error) {
	return uuid.UUID(c).MarshalText()
}

//TextUnmarshaler реализует интерфейс encoding.TextUnmarshaler
func (c *{{.Type}}) UnmarshalText(text []byte) error {
	return (*uuid.UUID)(c).UnmarshalText(text)
}

//ValueScanner реализует интерфейс entfield.ValueScanner
//из двух методов: Scan и Value
func (c *{{.Type}}) Scan(src interface{}) error {
	return (*uuid.UUID)(c).Scan(src)
}

func (c {{.Type}}) Value() (driver.Value, error) {
	return uuid.UUID(c).Value()
}

//Validator реализует интерфейс entfield.Validator
func (c {{.Type}}) Validate() error {
	if c == {{.Type}}Nil {
		return errors.New("{{.Type}} is nil")
	}
	return nil
}

//Matcher реализует интерфейс gomock.Matcher
func (c1 {{.Type}}) Matches(x interface{}) bool {
	if c2, ok := x.({{.Type}}); ok {
		return c1 == c2
	}
	if id, ok := x.(uuid.UUID); ok {
		return uuid.UUID(c1).String() == id.String()
	}
	return false
}

//New{{.Type}} создает новый {{.Type}}
func New{{.Type}}() {{.Type}} {
	return {{.Type}}(uuid.New())
}

//{{.Type}}Nil это nil {{.Type}}
var {{.Type}}Nil = {{.Type}}(uuid.Nil)

//IsZero проверяет, является ли {{.Type}} нулевым
func (c {{.Type}}) IsZero() bool {
	return c == {{.Type}}Nil
}
`

	// Подготавливаем шаблон
	tmpl, err := template.New("type").Parse(typeTpl)
	if err != nil {
		return fmt.Errorf("parse template: %w", err)
	}

	// Генерируем код для каждого типа
	for _, typeName := range types {
		// Пропускаем пустые имена типов
		if typeName == "" {
			continue
		}

		data := struct {
			Type string
		}{
			Type: typeName,
		}

		if err := tmpl.Execute(f, data); err != nil {
			return fmt.Errorf("execute template for %s: %w", typeName, err)
		}
	}

	// Добавляем обобщенные функции в конец файла для обратной совместимости
	footer := `
// Parse парсит строку и возвращает UUID тип
func Parse[T any](s string) (T, error) {	
	var result T
	id, err := uuid.Parse(s)
	if err != nil {
		return result, err
	}
	
	// Преобразуем uuid.UUID в нужный тип
	switch any(result).(type) {
	case ChatID:
		return any(ChatID(id)).(T), nil
	case MessageID:
		return any(MessageID(id)).(T), nil
	case ProblemID:
		return any(ProblemID(id)).(T), nil
	case UserID:
		return any(UserID(id)).(T), nil
	default:
		return any(id).(T), nil
	}
}

// MustParse парсит строку и возвращает UUID тип или паникует
func MustParse[T any](s string) T {
	var result T
	id, err := uuid.Parse(s)
	if err != nil {
		panic(err)
	}
	
	// Преобразуем uuid.UUID в нужный тип
	switch any(result).(type) {
	case ChatID:
		return any(ChatID(id)).(T)
	case MessageID:
		return any(MessageID(id)).(T)
	case ProblemID:
		return any(ProblemID(id)).(T)
	case UserID:
		return any(UserID(id)).(T)
	default:
		return any(id).(T)
	}
}
`
	if _, err := f.WriteString(footer); err != nil {
		return fmt.Errorf("write footer: %w", err)
	}

	return nil
}
